# 07. 데이터 모델 설계

**문서 버전**: 1.0  
**작성일**: 2025-10-01  
**최종 업데이트**: 2025-10-01 22:30  
**작성자**: Claude  
**상태**: ✅ Phase 2 완료

---

## 📋 목차

1. [개요](#개요)
2. [MySQL 스키마](#mysql-스키마)
3. [MongoDB 스키마](#mongodb-스키마)
4. [Weaviate 클래스](#weaviate-클래스)
5. [인덱스 전략](#인덱스-전략)
6. [데이터 흐름](#데이터-흐름)

---

## 개요

### 데이터베이스별 역할

- **MySQL**: 네이버 Commerce API 원본 데이터 저장 (Spring Boot)
- **MongoDB**: AI 에이전트용 제품/FAQ 데이터 (Python FastAPI)
- **Weaviate**: FAQ 의미적 벡터 검색 (Sentence-BERT 임베딩)

### 완료된 작업 (Phase 2)

- ✅ MySQL customer_inquiry 테이블 설계 및 데이터 100건 수집
- ✅ MongoDB 스키마 설계 (products, faqs, customers, logs)
- ✅ Keychron 제품 160개 JSON 변환 완료
- ✅ Weaviate FAQ 클래스 설계

---

## MySQL 스키마

### customer_inquiry 테이블

```sql
-- 2025-10-01, Claude 작성
-- 네이버 Commerce API 고객 문의 원본 데이터
CREATE TABLE customer_inquiry (
    inquiry_no BIGINT PRIMARY KEY,
    category VARCHAR(20),
    title VARCHAR(500),
    inquiry_content TEXT,
    inquiry_registration_date_time DATETIME,
    answered BOOLEAN DEFAULT FALSE,
    answer_content TEXT,
    order_id VARCHAR(100),
    product_no VARCHAR(100),
    product_name VARCHAR(500),
    customer_id VARCHAR(100),
    customer_name VARCHAR(100),
    processing_status ENUM('pending', 'exported_to_sheet', 'cs_reviewed', 'synced_to_mongo'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_status (processing_status),
    INDEX idx_category (category)
) ENGINE=InnoDB CHARSET=utf8mb4;
```

**처리 상태 흐름**:
1. `pending` → 네이버 API에서 수집
2. `exported_to_sheet` → Google Sheets 내보내기
3. `cs_reviewed` → CS 팀 검수 완료
4. `synced_to_mongo` → MongoDB 동기화 완료

---

## MongoDB 스키마

### products 컬렉션 (160개 제품 준비 완료)

```javascript
// 2025-10-01 22:30, Claude 작성
{
  _id: ObjectId("..."),
  product_id: "KB-K10-PRO-001",
  product_name: "K10 Pro",
  product_name_synonyms: ["K10Pro", "K10 프로"],
  price: 159000,
  discontinued: false,
  release_date: "2024-03-15",
  
  // 키보드 사양 (38개 컬럼 포함)
  keyboard_layout: "풀배열",
  keyboard_type: "기계식",
  switch_options: ["Gateron Brown", "Red", "Blue"],
  connection_method: "유선/무선/블루투스",
  battery_capacity: "4000mAh",
  hot_swap_socket: true,
  
  // 임베딩용 텍스트
  description_text: "K10 Pro는...",
  
  // 메타데이터
  created_at: ISODate("2025-10-01T22:00:00Z"),
  updated_at: ISODate("2025-10-01T22:00:00Z")
}
```

**인덱스**:
```javascript
db.products.createIndex({ product_id: 1 }, { unique: true })
db.products.createIndex({ product_name: 1 })
db.products.createIndex({ category: 1 })
db.products.createIndex({ discontinued: 1 })
```

### faqs 컬렉션

```javascript
// 2025-10-01 22:30, Claude 작성
{
  _id: ObjectId("..."),
  faq_id: "FAQ-001",
  
  // 질문/답변
  question: "K10 Pro는 Mac에서 사용 가능한가요?",
  answer: "네, Mac/Windows 모두 호환됩니다...",
  
  // 관련 정보
  related_products: ["KB-K10-PRO-001", "KB-K10-PRO-002"],
  category: "호환성",
  keywords: ["Mac", "호환성", "K10 Pro"],
  complexity_score: 0.3,  // 0.0~1.0
  
  // 통계
  view_count: 150,
  helpful_count: 48,
  
  // 메타데이터
  source: "naver_commerce",  // 출처
  source_inquiry_no: 12345,  // 원본 문의 번호
  created_by: "CS팀",
  reviewed_at: ISODate("2025-10-01T20:00:00Z"),
  created_at: ISODate("2025-10-01T19:00:00Z"),
  updated_at: ISODate("2025-10-01T20:00:00Z")
}
```

**인덱스**:
```javascript
db.faqs.createIndex({ faq_id: 1 }, { unique: true })
db.faqs.createIndex({ category: 1 })
db.faqs.createIndex({ keywords: 1 })
db.faqs.createIndex({ related_products: 1 })
db.faqs.createIndex({ complexity_score: 1 })
```

### customers 컬렉션

```javascript
{
  _id: ObjectId("..."),
  customer_id: "CUST-001",
  customer_name: "홍길동",
  email: "hong@example.com",
  
  // 구매 이력
  purchase_history: [
    {
      order_id: "ORDER-001",
      product_id: "KB-K10-PRO-001",
      purchase_date: ISODate("2024-12-01")
    }
  ],
  
  // 문의 이력
  inquiry_history: [
    {
      inquiry_no: 12345,
      inquiry_date: ISODate("2025-01-15"),
      category: "배송"
    }
  ],
  
  created_at: ISODate("2024-12-01"),
  updated_at: ISODate("2025-01-15")
}
```

### logs 컬렉션

```javascript
// 2025-10-01 22:30, Claude 작성
// AI 에이전트 실행 로그
{
  _id: ObjectId("..."),
  log_type: "answer_generation",  // 로그 유형
  
  // 요청 정보
  inquiry_no: 12345,
  question: "K10 Pro 배터리 수명은?",
  
  // 처리 정보
  vector_search_results: [...],  // 벡터 검색 결과
  confidence_score: 0.85,        // 신뢰도 점수
  answer_generated: true,        // 답변 생성 여부
  
  // 성능 메트릭
  processing_time_ms: 2500,
  api_calls: {
    weaviate: 1,
    mongodb: 2,
    claude: 1
  },
  
  // 메타데이터
  timestamp: ISODate("2025-10-01T22:30:00Z"),
  version: "1.0"
}
```

---

## Weaviate 클래스

### FAQClass (Phase 3에서 구현)

```python
# 2025-10-01 22:30, Claude 작성
# Weaviate FAQ 클래스 스키마
{
    "class": "FAQ",
    "description": "FAQ 질문-답변 쌍의 벡터 표현",
    "vectorizer": "none",  # Sentence-BERT로 직접 생성
    "properties": [
        {
            "name": "faq_id",
            "dataType": ["string"],
            "description": "MongoDB FAQ ID"
        },
        {
            "name": "question",
            "dataType": ["text"],
            "description": "FAQ 질문"
        },
        {
            "name": "answer",
            "dataType": ["text"],
            "description": "FAQ 답변"
        },
        {
            "name": "category",
            "dataType": ["string"],
            "description": "FAQ 카테고리"
        },
        {
            "name": "keywords",
            "dataType": ["string[]"],
            "description": "키워드 배열"
        },
        {
            "name": "related_products",
            "dataType": ["string[]"],
            "description": "관련 제품 ID 배열"
        },
        {
            "name": "complexity_score",
            "dataType": ["number"],
            "description": "복잡도 점수 (0.0~1.0)"
        }
    ],
    "vectorIndexConfig": {
        "distance": "cosine",  # 코사인 유사도
        "ef": 200,             # 검색 정확도
        "efConstruction": 128,  # 인덱스 구축 품질
        "maxConnections": 64    # HNSW 그래프 연결
    }
}
```

### 하이브리드 검색 전략

```python
# 2025-10-01 22:30, Claude 작성
# Weaviate 하이브리드 검색 쿼리 예시
def hybrid_search(question_embedding, keywords, category=None):
    """
    의미 검색 + 키워드 필터링 조합
    
    Args:
        question_embedding: Sentence-BERT 임베딩 벡터
        keywords: 추출된 키워드 리스트
        category: 카테고리 필터 (선택)
    """
    query = {
        "vector": question_embedding,
        "alpha": 0.7,  # 0.7 = 의미 검색 70% + 키워드 30%
        "limit": 10
    }
    
    # 키워드 필터 추가
    if keywords:
        query["where"] = {
            "operator": "Or",
            "operands": [
                {"path": ["keywords"], "operator": "ContainsAny", "valueString": keywords}
            ]
        }
    
    # 카테고리 필터 추가
    if category:
        query["where"]["operands"].append(
            {"path": ["category"], "operator": "Equal", "valueString": category}
        )
    
    return query
```

---

## 인덱스 전략

### MongoDB 인덱스 설계 원칙

**1. 자주 조회되는 필드에 인덱스 생성**
- product_id, faq_id (유일 인덱스)
- category, keywords (다중 인덱스)

**2. 복합 인덱스 활용**
```javascript
// 카테고리 + 복잡도 점수 복합 인덱스
db.faqs.createIndex({ category: 1, complexity_score: 1 })

// 제품 + 단종 여부 복합 인덱스
db.products.createIndex({ product_id: 1, discontinued: 1 })
```

**3. 텍스트 검색 인덱스**
```javascript
// FAQ 전문 검색
db.faqs.createIndex(
  { question: "text", answer: "text" },
  { default_language: "korean" }
)
```

### Weaviate HNSW 설정

**매개변수 설명**:
- `ef` (200): 검색 시 탐색할 이웃 수 (높을수록 정확하지만 느림)
- `efConstruction` (128): 인덱스 구축 시 품질 (높을수록 고품질)
- `maxConnections` (64): 각 노드의 최대 연결 수 (그래프 밀도)

**성능 예상**:
- FAQ 1,000개: 검색 시간 ~50ms
- FAQ 10,000개: 검색 시간 ~100ms
- FAQ 100,000개: 검색 시간 ~200ms

---

## 데이터 흐름

### 전체 파이프라인

```
1. 네이버 API (Spring Boot)
   ↓
2. MySQL customer_inquiry (원본 데이터)
   ↓
3. Python: MySQL → Google Sheets (CS 검수용)
   ↓
4. CS 팀: Google Sheets에서 답변 작성
   ↓
5. Python: Google Sheets → MongoDB faqs (검수 완료)
   ↓
6. Python: MongoDB faqs → Weaviate (임베딩 생성)
   ↓
7. AI 에이전트: Weaviate 검색 + MongoDB 조회 + Claude 답변
```

### Phase 3에서 구현할 작업

1. **MongoDB 데이터 임포트**
   - 제품 160개 JSON → MongoDB products
   - 인덱스 생성

2. **FAQ 임베딩 생성**
   - MongoDB faqs → Sentence-BERT
   - 임베딩 벡터 생성

3. **Weaviate 벡터 업로드**
   - FAQ 클래스 생성
   - 임베딩 벡터 + 메타데이터 업로드

4. **통합 테스트**
   - 하이브리드 검색 정확도 테스트
   - 응답 시간 측정 (~50ms 목표)

---

## 데이터 예시

### 실제 제품 데이터 (products_keychron.csv에서)

```json
{
  "product_id": "KB-K10-PRO-001",
  "product_name": "Keychron K10 Pro QMK/VIA Wireless Mechanical Keyboard",
  "price": 159000,
  "keyboard_layout": "풀배열 (100%)",
  "switch_options": ["Gateron Brown", "Red", "Blue", "Yellow"],
  "connection_method": "유선/무선/블루투스",
  "battery_capacity": "4000mAh",
  "bluetooth_runtime": "최대 200시간",
  "hot_swap_socket": true,
  "support_platforms": "Mac/Windows/Linux"
}
```

### 실제 FAQ 데이터 (100건 수집 완료)

```json
{
  "faq_id": "FAQ-001",
  "question": "K10 Pro는 Mac에서 Fn 키 기능이 작동하나요?",
  "answer": "네, Mac에서 완벽하게 작동합니다. Mac 모드로 전환하면 Fn 키가 Mac 전용 기능키로 매핑됩니다.",
  "category": "호환성",
  "keywords": ["Mac", "Fn 키", "K10 Pro", "호환성"],
  "related_products": ["KB-K10-PRO-001"],
  "complexity_score": 0.2,
  "source": "naver_commerce",
  "source_inquiry_no": 12345
}
```

---

**문서 버전**: 1.0  
**작성일**: 2025-10-01  
**최종 업데이트**: 2025-10-01 22:30  
**다음 업데이트**: Phase 3 시작 시 (실제 데이터 임포트 완료 후)
