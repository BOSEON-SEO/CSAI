# 08. 신뢰도 평가 시스템

**작성일**: 2025-09-30  
**최종 수정**: 2025-09-30 17:45, Claude 작성  
**상태**: ✅ 완료

---

## 목차

1. [개요](#개요)
2. [전체 흐름](#전체-흐름)
3. [1단계: 질문 복잡도 분석](#1단계-질문-복잡도-분석)
4. [2단계: 유사 FAQ 매칭 품질](#2단계-유사-faq-매칭-품질)
5. [3단계: 최종 신뢰도 계산](#3단계-최종-신뢰도-계산)
6. [의사결정 로직](#의사결정-로직)
7. [실제 동작 예시](#실제-동작-예시)
8. [경량 모델 판별 가능 이유](#경량-모델-판별-가능-이유)
9. [구현 코드](#구현-코드)

---

## 개요

신뢰도 평가 시스템은 **경량 모델(spaCy + Sentence-BERT)만으로** AI가 스스로 답변 가능한 질문과 CS 사원에게 이관해야 할 질문을 판별합니다.

### 핵심 목표

- ✅ **비용 절감**: Claude API 호출 전 필터링으로 30% 비용 절감
- ✅ **품질 보장**: 복잡한 질문은 전문가에게 이관
- ✅ **빠른 판단**: 15-20ms 이내 신뢰도 계산
- ✅ **투명한 근거**: 왜 이관되었는지 명확한 이유 제공

### 신뢰도 점수 의미

| 신뢰도 | 의사결정 | 의미 | 처리 방식 |
|--------|---------|------|----------|
| **0.85 ~ 1.0** | `auto` | 매우 높음 | 완전 자동 (검수 없이 바로 등록) |
| **0.70 ~ 0.84** | `review` | 높음 | AI 답변 생성 + CS 검수 |
| **0.0 ~ 0.69** | `escalate` | 낮음 | CS 사원 직접 처리 |

---

## 전체 흐름

```
┌─────────────────────┐
│   질문 입력         │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ [1단계]             │
│ 질문 복잡도 분석    │◄─── spaCy + Sentence-BERT (15-20ms)
│ - 기술적 복잡도     │
│ - 구조적 복잡도     │
│ - 불확실성 점수     │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ [2단계]             │
│ 유사 FAQ 검색       │◄─── Weaviate (50ms)
│ - 벡터 유사도       │
│ - 매칭 품질 분석    │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ [3단계]             │
│ 신뢰도 점수 계산    │◄─── Python 로직 (5ms)
│ confidence = f(     │
│   complexity,       │
│   match_quality,    │
│   product_info      │
│ )                   │
└──────────┬──────────┘
           │
           ▼
    신뢰도 >= 0.70?
           │
    ┌──────┴──────┐
    │             │
   YES            NO
    │             │
    ▼             ▼
┌─────────┐  ┌──────────┐
│ Claude  │  │ CS 사원  │
│ 답변 생성│  │ 직접 처리│
└─────────┘  └──────────┘
```

**전체 소요 시간**: 70-75ms (Claude 호출 전)

---

## 1단계: 질문 복잡도 분석

경량 모델이 질문의 **형태**와 **구조**를 분석하여 복잡도를 점수화합니다.

### A. 기술적 복잡도 (Technical Complexity Score)

**목적**: 전문 지식이 필요한 용어가 포함되었는지 판단

#### 기술 용어 사전 (3단계 분류)

```python
technical_terms = {
    'high': [  # 전문가 필수 (가중치 3.0)
        '펌웨어', 'firmware', '드라이버', 'driver',
        '호환성', 'compatibility', '바이오스', 'bios',
        '커널패닉', 'kernel panic', 'DMA', 'IRQ',
        '레지스트리', 'registry', 'bootloader'
    ],
    'medium': [  # 일부 지식 필요 (가중치 2.0)
        'USB', '블루투스', 'bluetooth', 'RGB',
        '매크로', 'macro', '키매핑', 'keymapping',
        '폴링레이트', 'polling rate', 'DPI', 'LED'
    ],
    'low': [  # 일반 용어 (가중치 1.0)
        '키보드', 'keyboard', '마우스', 'mouse',
        '배송', '반품', '교환', 'A/S', '색상'
    ]
}
```

#### 계산 공식

```
기술 점수 = min(Σ(용어 가중치) / 10.0, 1.0)
```

#### 예시

**질문 1**: "키보드 배송 언제 오나요?"
```
용어: '키보드'(1.0) + '배송'(1.0) = 2.0
점수: 2.0 / 10.0 = 0.20 (낮음 ✓)
```

**질문 2**: "펌웨어 v2.3에서 매크로 실행 시 커널패닉 발생"
```
용어: '펌웨어'(3.0) + '매크로'(2.0) + '커널패닉'(3.0) = 8.0
점수: 8.0 / 10.0 = 0.80 (높음 ✗)
```

---

### B. 구조적 복잡도 (Structural Complexity)

**목적**: 문장 구조의 복잡성 평가

#### 분석 요소

1. **문장 길이**: 단어 수
2. **복문 개수**: 접속사 ('그리고', '하지만', '그런데', '그래서', '또한')
3. **의존 관계 깊이**: spaCy dependency tree의 최대 깊이

#### 계산 공식

```
구조 점수 = (
    length_score * 0.3 +      # 문장 길이 (50단어 기준)
    conj_score * 0.3 +         # 복문 개수 (3개 기준)
    depth_score * 0.4          # 의존 깊이 (5 기준)
)

length_score = min(단어수 / 50.0, 1.0)
conj_score = min(접속사수 / 3.0, 1.0)
depth_score = min(최대깊이 / 5.0, 1.0)
```

#### 예시

**질문 1**: "배송 언제 오나요?"
```
단어: 3개, 복문: 0개, 깊이: 2
점수: (3/50*0.3) + (0/3*0.3) + (2/5*0.4) = 0.018 + 0 + 0.16 = 0.18 (단순 ✓)
```

**질문 2**: "USB 연결했는데 인식은 되는데 키 입력은 안되고 RGB는 들어오는데..."
```
단어: 12개, 복문: 3개, 깊이: 4
점수: (12/50*0.3) + (3/3*0.3) + (4/5*0.4) = 0.072 + 0.3 + 0.32 = 0.69 (복잡 ✗)
```

---

### C. 불확실성 점수 (Uncertainty Score)

**목적**: 오류/문제 상황 감지 (전문가 개입 필요성)

#### 불확실성 키워드

```python
uncertainty_keywords = [
    '안되', '작동 안', '인식 안', '연결 안',
    '오류', 'error', '문제', 'problem',
    '이상하', '갑자기', '가끔', '때때로',
    '먹통', '멈춤', '끊김', '느려'
]
```

#### 계산 공식

```
불확실성 점수 = min(키워드_개수 / 3.0, 1.0)

보정:
- 부정어('안', '못', '없') + 질문 아님 → +0.2
  (예: "안돼요" - 문제 진술)
```

#### 예시

**질문 1**: "RGB 색상 변경 방법은?"
```
키워드: 없음
점수: 0.0 (명확 ✓)
```

**질문 2**: "USB 연결했는데 안돼요"
```
키워드: '안되'(1개)
부정어 포함 + 질문 아님 → 보정 +0.2
점수: min(1/3 + 0.2, 1.0) = 0.53 (불확실 ✗)
```

---

### 종합 복잡도 계산

#### 가중 평균

```
overall_complexity = (
    technical * 0.5 +      # 기술 복잡도 (가장 중요)
    structural * 0.25 +    # 구조 복잡도
    uncertainty * 0.25     # 불확실성
)
```

#### 카테고리 분류

```python
if overall < 0.3:
    category = 'simple'      # 단순 - AI 자동 처리 가능
elif overall < 0.6:
    category = 'moderate'    # 중간 - AI + CS 검수
else:
    category = 'complex'     # 복잡 - CS 직접 처리
```

---

## 2단계: 유사 FAQ 매칭 품질

Weaviate에서 검색된 FAQ 결과의 **품질**을 평가합니다.

### 매칭 품질 평가 요소

1. **최상위 유사도** (50%)
   - Weaviate distance (낮을수록 유사)
   - `similarity = 1.0 - distance`

2. **상위 결과 일관성** (30%)
   - 상위 3개 결과의 거리 편차
   - 편차 작을수록 명확한 답변 존재

3. **카테고리 일치도** (20%)
   - 상위 5개 중 같은 카테고리 비율
   - 카테고리 일치율 높을수록 주제 명확

### 계산 공식

```python
# 1. 최상위 유사도
top_similarity = 1.0 - search_results[0]['distance']

# 2. 일관성 (상위 3개 거리 편차)
top3_distances = [r['distance'] for r in search_results[:3]]
consistency = 1.0 - (max(top3_distances) - min(top3_distances))

# 3. 카테고리 일치도
top_category = search_results[0]['category']
category_match = sum(
    1 for r in search_results[:5] 
    if r['category'] == top_category
) / 5

# 종합
match_quality = (
    top_similarity * 0.5 +
    consistency * 0.3 +
    category_match * 0.2
)
```

### 예시

#### 높은 매칭 품질

**질문**: "키보드 RGB 색상 변경 방법"

```
검색 결과:
1. "RGB 설정 어떻게 하나요?" (distance: 0.12, category: '기능')
2. "LED 색 바꾸는 법" (distance: 0.15, category: '기능')
3. "RGB 모드 변경" (distance: 0.18, category: '기능')

계산:
- top_similarity = 1.0 - 0.12 = 0.88
- consistency = 1.0 - (0.18 - 0.12) = 0.94
- category_match = 5/5 = 1.0

match_quality = 0.88*0.5 + 0.94*0.3 + 1.0*0.2 = 0.92 (매우 높음 ✓)
```

#### 낮은 매칭 품질

**질문**: "USB-C 케이블 연결했는데 가끔 끊겨요"

```
검색 결과:
1. "USB 연결 문제" (distance: 0.35, category: '기술지원')
2. "배송 지연" (distance: 0.42, category: '배송')
3. "반품 절차" (distance: 0.45, category: '교환/반품')

계산:
- top_similarity = 1.0 - 0.35 = 0.65
- consistency = 1.0 - (0.45 - 0.35) = 0.90
- category_match = 1/5 = 0.2

match_quality = 0.65*0.5 + 0.90*0.3 + 0.2*0.2 = 0.63 (낮음 ✗)
```

---

## 3단계: 최종 신뢰도 계산

복잡도와 매칭 품질을 종합하여 **최종 신뢰도 점수**를 산출합니다.

### 신뢰도 계산 공식

```python
confidence = (
    (1.0 - complexity_overall) * 0.4 +  # 복잡도 낮을수록 좋음
    match_quality * 0.4 +                # 매칭 품질
    product_info_score * 0.2             # 제품 정보 가용성
)
```

### 제품 정보 가용성

특정 질문은 제품 정보가 필수입니다.

#### 제품 정보 필요 키워드

```python
product_keywords = [
    '스펙', '호환', '지원', '버전', '모델',
    '크기', '무게', '배터리', '연결'
]
```

#### 점수 부여

- 제품 정보 필요 + 있음 → `1.0`
- 제품 정보 필요 + 없음 → `0.3` (대폭 감점)
- 제품 정보 불필요 → `1.0`

---

## 의사결정 로직

### 임계값 설정

| 임계값 | 의사결정 | 예상 정확도 | 설명 |
|--------|---------|-----------|------|
| **0.85** | `auto` | 95%+ | 완전 자동 처리 (검수 불필요) |
| **0.70** | `review` | 85~95% | AI 답변 생성 + CS 검수 필수 |
| **0.00** | `escalate` | < 85% | CS 사원 직접 처리 |

### 의사결정 알고리즘

```python
if confidence >= 0.85:
    decision = 'auto'
    reason = "높은 신뢰도 - 자동 답변 가능"
    
elif confidence >= 0.70:
    decision = 'review'
    reason = "중간 신뢰도 - AI 답변 생성 후 CS 검수 필요"
    
else:
    decision = 'escalate'
    reason = _generate_escalation_reason(complexity, match_quality)
```

### 이관 사유 생성

```python
def _generate_escalation_reason(complexity, match_quality):
    reasons = []
    
    if complexity['overall'] > 0.6:
        reasons.append(f"높은 기술적 복잡도({complexity['category']})")
    
    if match_quality < 0.4:
        reasons.append("유사 FAQ 부족")
    
    if complexity['uncertainty'] > 0.5:
        reasons.append("오류/문제 상황으로 전문가 확인 필요")
    
    return " / ".join(reasons) if reasons else "신뢰도 부족"
```

### 임계값 0.70 선정 근거

1. **보수적 접근**: 초기엔 안전 중시
2. **조정 가능**: Phase 5 테스트에서 데이터 기반 최적화
3. **비용 균형**: 너무 낮으면 CS 부담 증가, 너무 높으면 AI 활용도 하락
4. **업계 표준**: 일반적인 AI 시스템의 신뢰 임계값 (70-80%)

---

## 실제 동작 예시

### 예시 1: 간단한 질문 (AI 자동 처리)

#### 질문
```
"KB-TKL-001 배송은 얼마나 걸리나요?"
```

#### [1단계] 복잡도 분석
```python
complexity = {
    'technical': 0.15,      # '키보드', '배송' (일반 용어)
    'structural': 0.10,     # 단순 문장 (7단어)
    'uncertainty': 0.0,     # 명확한 질문
    'overall': 0.12,        # 0.15*0.5 + 0.10*0.25 + 0*0.25
    'category': 'simple'
}
```

#### [2단계] FAQ 검색
```python
search_results = [
    {'distance': 0.08, 'text': '배송 기간은 2-3일...', 'category': '배송'},
    {'distance': 0.12, 'text': '주문 후 배송 일정...', 'category': '배송'},
    {'distance': 0.14, 'text': '배송비와 기간...', 'category': '배송'}
]

match_quality = 0.91
# top_similarity = 0.92, consistency = 0.94, category_match = 1.0
```

#### [3단계] 신뢰도 계산
```python
confidence = (1.0 - 0.12) * 0.4 + 0.91 * 0.4 + 1.0 * 0.2
           = 0.352 + 0.364 + 0.2
           = 0.916
```

#### 결과
```python
{
    'confidence': 0.916,
    'decision': 'auto',
    'reason': '높은 신뢰도 - 자동 답변 가능',
    'action': 'Claude API 호출 → 답변 생성 → 검수 없이 바로 등록'
}
```

✅ **성공**: 완전 자동 처리

---

### 예시 2: 중간 복잡도 (AI 생성 + CS 검수)

#### 질문
```
"KB-RGB-500에서 RGB 효과 설정이 저장 안되는데 펌웨어 문제인가요?"
```

#### [1단계] 복잡도 분석
```python
complexity = {
    'technical': 0.55,      # '펌웨어'(3.0), 'RGB'(2.0)
    'structural': 0.40,     # 복문 포함 (12단어, 접속사 1개)
    'uncertainty': 0.60,    # '안되' + 문제 상황
    'overall': 0.53,        # 0.55*0.5 + 0.40*0.25 + 0.60*0.25
    'category': 'moderate'
}
```

#### [2단계] FAQ 검색
```python
search_results = [
    {'distance': 0.25, 'text': 'RGB 설정 초기화...', 'category': '기술지원'},
    {'distance': 0.30, 'text': '펌웨어 업데이트 방법...', 'category': '기술지원'},
    {'distance': 0.33, 'text': 'RGB 저장 안됨...', 'category': '기술지원'}
]

match_quality = 0.68
# top_similarity = 0.75, consistency = 0.92, category_match = 1.0
```

#### [3단계] 신뢰도 계산
```python
confidence = (1.0 - 0.53) * 0.4 + 0.68 * 0.4 + 1.0 * 0.2
           = 0.188 + 0.272 + 0.2
           = 0.660
```

#### 결과
```python
{
    'confidence': 0.660,
    'decision': 'review',  # 0.70 미만
    'reason': '중간 신뢰도 - AI 답변 생성 후 CS 검수 필요',
    'action': 'Claude API 호출 → 답변 생성 → CS 검수 대기열 추가'
}
```

⚠️ **주의**: AI가 답변 생성하지만 CS 검수 필수

---

### 예시 3: 복잡한 질문 (CS 사원 직접 처리)

#### 질문
```
"Windows 11에서 USB 3.2 Gen 2 포트에 연결했는데 간헐적으로 끊기고 
장치 관리자에서 Code 43 오류 나옵니다. 
드라이버는 최신인데 BIOS 설정 문제일까요?"
```

#### [1단계] 복잡도 분석
```python
complexity = {
    'technical': 0.85,      # 'USB 3.2'(2.0), 'Code 43'(3.0), 
                            # '드라이버'(3.0), 'BIOS'(3.0)
    'structural': 0.75,     # 긴 복문 (25단어, 접속사 2개, 깊이 5)
    'uncertainty': 0.80,    # '간헐적', '끊기', '오류'
    'overall': 0.82,        # 0.85*0.5 + 0.75*0.25 + 0.80*0.25
    'category': 'complex'
}
```

#### [2단계] FAQ 검색
```python
search_results = [
    {'distance': 0.45, 'text': 'USB 연결 문제...', 'category': '일반'},
    {'distance': 0.50, 'text': '장치 인식 안됨...', 'category': '일반'},
    {'distance': 0.52, 'text': 'USB 포트 설정...', 'category': '기술지원'}
]

match_quality = 0.38
# top_similarity = 0.55, consistency = 0.93, category_match = 0.4
```

#### [3단계] 신뢰도 계산
```python
confidence = (1.0 - 0.82) * 0.4 + 0.38 * 0.4 + 1.0 * 0.2
           = 0.072 + 0.152 + 0.2
           = 0.424
```

#### 결과
```python
{
    'confidence': 0.424,
    'decision': 'escalate',
    'reason': '높은 기술적 복잡도(complex) / 유사 FAQ 부족 / 오류/문제 상황으로 전문가 확인 필요',
    'action': 'Claude 호출 안 함 → CS 사원 직접 처리 대기열'
}
```

❌ **이관**: AI가 답변하지 않고 CS 사원에게 전달

---

## 경량 모델 판별 가능 이유

### 왜 Claude 없이 경량 모델만으로 판별 가능한가?

#### 1. 패턴 인식 문제이지 답변 생성이 아님

```
❌ 필요 없음: "이 질문에 뭐라고 답해야 할까?" (의미 이해)
✅ 필요함: "이 질문은 복잡한가? 간단한가?" (패턴 분석)
```

- 답변 **내용** 이해 불필요
- 질문의 **형태**와 **구조**만 분석

#### 2. 명확한 규칙 기반

```python
# 규칙 1: 기술 용어 사전 매칭
if '펌웨어' in question or 'BIOS' in question:
    technical_score += 3.0

# 규칙 2: 문장 길이 계산
if word_count > 50:
    structural_score = 1.0

# 규칙 3: FAQ 유사도 거리 측정
if weaviate_distance < 0.2:
    match_quality = 'high'
```

→ **LLM 불필요**, 간단한 알고리즘으로 충분

#### 3. 빠른 속도 (15-20ms)

| 작업 | 모델 | 소요 시간 |
|------|------|----------|
| 형태소 분석 | spaCy (CPU) | 10ms |
| 의미 임베딩 | Sentence-BERT (GPU) | 5-10ms |
| 점수 계산 | Python 로직 | <1ms |
| **합계** | | **15-20ms** |

→ 실시간 필터링 가능

#### 4. 비용 효율

**시나리오**: 월 900건 질문

```
[기존] 전부 Claude 호출
900건 × $0.05 = $45

[신뢰도 필터링] 30% 이관
경량 모델: 900건 × $0 = $0
Claude: 630건 × $0.05 = $31.50

절감액: $13.50 (30% 절감)
```

→ 경량 모델 비용 $0, Claude 호출 70%만

#### 5. 확장 가능성

- **파인튜닝 가능**: 자사 FAQ 데이터로 Sentence-BERT 재학습
- **지속 개선**: 이관 사유 데이터 축적 → 알고리즘 최적화
- **멀티모달 확장**: 이미지 첨부 시 Vision 모델 추가 가능

---

## 구현 코드

### ComplexityAnalyzer 클래스

```python
# 2025-09-30 17:45, Claude 작성
import spacy
from typing import Dict, List

class ComplexityAnalyzer:
    """
    질문의 복잡도를 분석하는 클래스
    
    복잡도는 다음 세 가지 차원으로 평가됩니다:
    1. 기술적 복잡도 (technical)
    2. 구조적 복잡도 (structural)
    3. 불확실성 점수 (uncertainty)
    """
    
    def __init__(self):
        """복잡도 분석기 초기화"""
        self.nlp = spacy.load("ko_core_news_lg")
        
        # 기술 용어 사전 (3단계 분류)
        self.technical_terms = {
            'high': [  # 전문가 필수 (가중치 3.0)
                '펌웨어', 'firmware', '드라이버', 'driver',
                '호환성', 'compatibility', '바이오스', 'bios',
                '커널패닉', 'kernel panic', 'DMA', 'IRQ',
                '레지스트리', 'registry', 'bootloader',
                'efi', 'uefi', '파티션', 'partition'
            ],
            'medium': [  # 일부 지식 필요 (가중치 2.0)
                'usb', '블루투스', 'bluetooth', 'rgb', 'led',
                '매크로', 'macro', '키매핑', 'keymapping',
                '폴링레이트', 'polling rate', 'dpi', '해상도',
                '무선', 'wireless', '유선', 'wired'
            ],
            'low': [  # 일반 용어 (가중치 1.0)
                '키보드', 'keyboard', '마우스', 'mouse',
                '배송', '반품', '교환', 'a/s', '색상',
                '사이즈', '무게', '박스', '포장'
            ]
        }
        
        # 불확실성 키워드
        self.uncertainty_keywords = [
            '안되', '안돼', '작동 안', '인식 안', '연결 안',
            '오류', 'error', '문제', 'problem', 'issue',
            '이상하', '이상해', '갑자기', '가끔', '때때로',
            '먹통', '멈춤', '끊김', '느려', '늦',
            '실패', 'fail', 'crash', '다운'
        ]
        
        # 접속사 (복문 판단)
        self.conjunctions = [
            '그리고', '하지만', '그런데', '그래서', '또한',
            '그러나', '따라서', '즉', '또는', '혹은'
        ]
    
    def calculate_technical_score(self, text: str) -> float:
        """
        기술적 복잡도 점수 계산 (0.0 ~ 1.0)
        
        Args:
            text: 분석할 질문 텍스트
            
        Returns:
            float: 복잡도 점수 (높을수록 복잡)
        """
        text_lower = text.lower()
        score = 0.0
        
        # 기술 용어 가중치 계산
        for level, terms in self.technical_terms.items():
            weight = {'high': 3.0, 'medium': 2.0, 'low': 1.0}[level]
            for term in terms:
                if term in text_lower:
                    score += weight
        
        # 정규화 (0.0 ~ 1.0, 10점 만점 기준)
        normalized_score = min(score / 10.0, 1.0)
        
        # 용어가 전혀 없으면 중간값
        if score == 0:
            normalized_score = 0.5
        
        return round(normalized_score, 3)
    
    def calculate_structural_score(self, text: str) -> float:
        """
        문장 구조의 복잡도 계산 (0.0 ~ 1.0)
        
        복잡도 지표:
        - 문장 길이 (단어 수)
        - 복문 개수 (접속사)
        - 의존 관계 깊이
        
        Args:
            text: 분석할 질문 텍스트
            
        Returns:
            float: 구조 복잡도 점수
        """
        doc = self.nlp(text)
        
        # 1. 문장 길이
        word_count = len([token for token in doc if not token.is_punct])
        length_score = min(word_count / 50.0, 1.0)  # 50단어 이상이면 1.0
        
        # 2. 복문 개수
        conj_count = sum(1 for token in doc if token.text in self.conjunctions)
        conj_score = min(conj_count / 3.0, 1.0)  # 3개 이상이면 1.0
        
        # 3. 의존 관계 깊이 (spaCy dependency tree)
        max_depth = self._get_max_dependency_depth(doc)
        depth_score = min(max_depth / 5.0, 1.0)  # 깊이 5 이상이면 1.0
        
        # 가중 평균
        structural_score = (
            length_score * 0.3 + 
            conj_score * 0.3 + 
            depth_score * 0.4
        )
        
        return round(structural_score, 3)
    
    def _get_max_dependency_depth(self, doc) -> int:
        """
        의존 관계 트리의 최대 깊이 계산
        
        Args:
            doc: spaCy Doc 객체
            
        Returns:
            int: 최대 깊이
        """
        def get_depth(token, current_depth=0):
            """재귀적으로 토큰의 하위 트리 깊이 계산"""
            children = list(token.children)
            if not children:
                return current_depth
            return max(get_depth(child, current_depth + 1) for child in children)
        
        if not list(doc.sents):
            return 0
        
        return max(get_depth(sent.root) for sent in doc.sents)
    
    def calculate_uncertainty_score(self, text: str) -> float:
        """
        불확실성 및 오류 관련성 점수 계산 (0.0 ~ 1.0)
        
        오류/문제 상황일수록 전문가 필요성 높음
        
        Args:
            text: 분석할 질문 텍스트
            
        Returns:
            float: 불확실성 점수
        """
        text_lower = text.lower()
        
        # 불확실성 키워드 개수
        uncertainty_count = sum(
            1 for keyword in self.uncertainty_keywords 
            if keyword in text_lower
        )
        
        # 질문 형태 분석
        has_question_mark = '?' in text or '?' in text
        has_negative = any(neg in text for neg in ['안', '못', '없'])
        
        base_score = min(uncertainty_count / 3.0, 1.0)
        
        # 보정: 부정어 포함 + 질문 아님 → 문제 진술로 판단
        if has_negative and not has_question_mark:
            base_score = min(base_score + 0.2, 1.0)
        
        return round(base_score, 3)
    
    def get_overall_complexity(self, text: str) -> Dict:
        """
        전체 복잡도 점수 및 상세 정보 반환
        
        Args:
            text: 분석할 질문 텍스트
            
        Returns:
            dict: {
                'technical': float,      # 기술 복잡도
                'structural': float,     # 구조 복잡도
                'uncertainty': float,    # 불확실성
                'overall': float,        # 종합 점수
                'category': str          # 'simple' | 'moderate' | 'complex'
            }
        """
        technical = self.calculate_technical_score(text)
        structural = self.calculate_structural_score(text)
        uncertainty = self.calculate_uncertainty_score(text)
        
        # 가중 평균 (기술적 복잡도가 가장 중요)
        overall = (
            technical * 0.5 + 
            structural * 0.25 + 
            uncertainty * 0.25
        )
        
        # 카테고리 분류
        if overall < 0.3:
            category = 'simple'
        elif overall < 0.6:
            category = 'moderate'
        else:
            category = 'complex'
        
        return {
            'technical': technical,
            'structural': structural,
            'uncertainty': uncertainty,
            'overall': round(overall, 3),
            'category': category
        }
```

---

### MatchQualityAnalyzer 클래스

```python
# 2025-09-30 17:45, Claude 작성
from typing import List, Dict

class MatchQualityAnalyzer:
    """
    Weaviate에서 검색된 FAQ의 매칭 품질 분석
    """
    
    def calculate_match_quality(self, 
                               query: str, 
                               search_results: List[Dict]) -> float:
        """
        유사 FAQ 검색 결과의 품질 점수 계산
        
        평가 요소:
        1. 최상위 결과의 유사도 (50%)
        2. 상위 3개 결과의 일관성 (30%)
        3. 카테고리 일치도 (20%)
        
        Args:
            query: 원본 질문
            search_results: Weaviate 검색 결과 리스트
                [
                    {
                        'distance': float,      # 벡터 거리 (낮을수록 유사)
                        'text': str,            # FAQ 텍스트
                        'category': str         # FAQ 카테고리
                    },
                    ...
                ]
        
        Returns:
            float: 매칭 품질 점수 (0.0 ~ 1.0)
        """
        if not search_results:
            return 0.0
        
        # 1. 최상위 결과의 유사도 (distance가 낮을수록 유사)
        top_similarity = 1.0 - search_results[0]['distance']
        
        # 2. 상위 3개 결과의 일관성
        if len(search_results) >= 3:
            top3_distances = [r['distance'] for r in search_results[:3]]
            # 거리 편차가 작을수록 일관성 높음
            consistency = 1.0 - (max(top3_distances) - min(top3_distances))
        else:
            consistency = top_similarity
        
        # 3. 카테고리 일치도
        top_category = search_results[0].get('category')
        if top_category:
            category_match = sum(
                1 for r in search_results[:5] 
                if r.get('category') == top_category
            ) / min(len(search_results), 5)
        else:
            category_match = 0.5  # 카테고리 정보 없으면 중간값
        
        # 종합 점수
        quality_score = (
            top_similarity * 0.5 + 
            consistency * 0.3 + 
            category_match * 0.2
        )
        
        return round(quality_score, 3)
    
    def get_quality_details(self, 
                           search_results: List[Dict]) -> Dict:
        """
        매칭 품질 상세 정보 반환
        
        Args:
            search_results: Weaviate 검색 결과
            
        Returns:
            dict: {
                'top_similarity': float,
                'consistency': float,
                'category_match': float,
                'top_category': str
            }
        """
        if not search_results:
            return {
                'top_similarity': 0.0,
                'consistency': 0.0,
                'category_match': 0.0,
                'top_category': None
            }
        
        top_similarity = 1.0 - search_results[0]['distance']
        
        if len(search_results) >= 3:
            top3_distances = [r['distance'] for r in search_results[:3]]
            consistency = 1.0 - (max(top3_distances) - min(top3_distances))
        else:
            consistency = top_similarity
        
        top_category = search_results[0].get('category')
        if top_category:
            category_match = sum(
                1 for r in search_results[:5] 
                if r.get('category') == top_category
            ) / min(len(search_results), 5)
        else:
            category_match = 0.5
        
        return {
            'top_similarity': round(top_similarity, 3),
            'consistency': round(consistency, 3),
            'category_match': round(category_match, 3),
            'top_category': top_category
        }
```

---

### ConfidenceScorer 클래스

```python
# 2025-09-30 17:45, Claude 작성
from typing import Dict, List, Optional

class ConfidenceScorer:
    """
    최종 신뢰도 점수 계산 및 답변 가능 여부 판단
    """
    
    def __init__(self):
        """신뢰도 평가기 초기화"""
        self.complexity_analyzer = ComplexityAnalyzer()
        self.match_analyzer = MatchQualityAnalyzer()
        
        # 임계값 설정
        self.CONFIDENCE_THRESHOLD = 0.70  # 70% 이상이면 AI 처리
        self.HIGH_CONFIDENCE = 0.85       # 85% 이상이면 완전 자동
        
        # 제품 정보 필요 키워드
        self.product_keywords = [
            '스펙', '호환', '지원', '버전', '모델',
            '크기', '무게', '배터리', '연결',
            '치수', '사양', '성능'
        ]
    
    def calculate_confidence(self, 
                           question: str,
                           search_results: List[Dict],
                           product_info: Optional[Dict] = None) -> Dict:
        """
        최종 신뢰도 계산 및 의사결정
        
        Args:
            question: 원본 질문
            search_results: Weaviate 검색 결과
            product_info: 제품 정보 (선택)
            
        Returns:
            dict: {
                'confidence': float,         # 신뢰도 점수
                'decision': str,             # 'auto' | 'review' | 'escalate'
                'reason': str,               # 의사결정 사유
                'details': dict              # 상세 정보
            }
        """
        # 1. 복잡도 분석
        complexity = self.complexity_analyzer.get_overall_complexity(question)
        
        # 2. 매칭 품질 분석
        match_quality = self.match_analyzer.calculate_match_quality(
            question, search_results
        )
        
        # 3. 제품 정보 가용성 (선택적)
        product_score = 1.0
        if self._requires_product_info(question):
            product_score = 1.0 if product_info else 0.3
        
        # 4. 최종 신뢰도 계산
        # 복잡도가 낮고 + 매칭이 좋을수록 신뢰도 높음
        confidence = (
            (1.0 - complexity['overall']) * 0.4 +  # 복잡도 낮을수록 좋음
            match_quality * 0.4 +                   # 매칭 품질
            product_score * 0.2                     # 제품 정보 가용성
        )
        
        # 5. 의사결정
        if confidence >= self.HIGH_CONFIDENCE:
            decision = 'auto'
            reason = "높은 신뢰도 - 자동 답변 가능"
        elif confidence >= self.CONFIDENCE_THRESHOLD:
            decision = 'review'
            reason = "중간 신뢰도 - AI 답변 생성 후 CS 검수 필요"
        else:
            decision = 'escalate'
            reason = self._get_escalation_reason(complexity, match_quality)
        
        return {
            'confidence': round(confidence, 3),
            'decision': decision,
            'reason': reason,
            'details': {
                'complexity': complexity,
                'match_quality': match_quality,
                'product_score': product_score,
                'requires_product_info': self._requires_product_info(question)
            }
        }
    
    def _requires_product_info(self, question: str) -> bool:
        """
        제품 정보가 필요한 질문인지 판단
        
        Args:
            question: 질문 텍스트
            
        Returns:
            bool: 제품 정보 필요 여부
        """
        return any(keyword in question for keyword in self.product_keywords)
    
    def _get_escalation_reason(self, 
                               complexity: Dict, 
                               match_quality: float) -> str:
        """
        이관 사유 생성
        
        Args:
            complexity: 복잡도 분석 결과
            match_quality: 매칭 품질 점수
            
        Returns:
            str: 이관 사유
        """
        reasons = []
        
        if complexity['overall'] > 0.6:
            reasons.append(f"높은 기술적 복잡도({complexity['category']})")
        
        if match_quality < 0.4:
            reasons.append("유사 FAQ 부족")
        
        if complexity['uncertainty'] > 0.5:
            reasons.append("오류/문제 상황으로 전문가 확인 필요")
        
        return " / ".join(reasons) if reasons else "신뢰도 부족"
    
    def batch_evaluate(self, 
                      questions: List[str],
                      search_results_list: List[List[Dict]]) -> List[Dict]:
        """
        여러 질문을 일괄 평가
        
        Args:
            questions: 질문 리스트
            search_results_list: 각 질문에 대한 검색 결과 리스트
            
        Returns:
            list: 각 질문의 신뢰도 평가 결과
        """
        results = []
        
        for question, search_results in zip(questions, search_results_list):
            result = self.calculate_confidence(question, search_results)
            result['question'] = question
            results.append(result)
        
        return results
```

---

## 성능 지표 (예상)

### 정확도 목표

| 지표 | 목표 | 측정 방법 |
|------|------|----------|
| **정확도** | 85%+ | CS 사원이 AI 판단 동의 비율 |
| **오탐률** (False Positive) | < 10% | auto/review인데 실제론 complex |
| **미탐률** (False Negative) | < 5% | escalate인데 실제론 simple |
| **처리 시간** | < 20ms | 복잡도 분석 전체 소요 시간 |

### Phase 5 테스트에서 측정 예정

- [ ] 50개 샘플 질문 수동 라벨링
- [ ] 신뢰도 점수와 CS 사원 판단 비교
- [ ] 임계값 조정 (0.70 → 최적값 탐색)
- [ ] 오류 사례 분석 및 알고리즘 개선

---

## 향후 개선 계획

### Phase 6 이후

1. **머신러닝 기반 최적화**
   - 축적된 이관 데이터로 분류 모델 학습
   - 임계값 동적 조정

2. **도메인 특화**
   - 자사 제품명 자동 추출 및 사전 업데이트
   - 카테고리별 복잡도 가중치 조정

3. **A/B 테스트**
   - 임계값 0.70 vs 0.75 성능 비교
   - 가중치 조합 최적화

4. **실시간 학습**
   - CS 사원 피드백 반영
   - 잘못 판단된 케이스 자동 보정

---

**문서 버전**: 1.0  
**다음 업데이트**: Phase 3 (AI 코어 개발) 완료 시  
**작성자**: Claude  
**검토자**: (Phase 3에서 개발자 검토 예정)
