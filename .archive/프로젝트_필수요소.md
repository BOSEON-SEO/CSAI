# 대규모 프로젝트 필수 요소

## 1. 아이디어 발굴 단계
- **브레인스토밍 문서**: 자유로운 아이디어 나열, 마인드맵 형태
- **컨셉 스케치**: 핵심 아이디어를 시각적으로 표현한 간단한 다이어그램

## 2. 프로젝트 정의 단계
- **프로젝트 비전 & 목표 문서**: 왜 이걸 하는지, 무엇을 달성하려는지
- **타겟 사용자/페르소나**: 누구를 위한 프로젝트인지
- **핵심 가치 제안**: 이 프로젝트의 독특한 점

## 3. 기획 & 설계 단계
- **요구사항 명세서**: 기능 목록, 우선순위, 제약사항
- **시스템 아키텍처 다이어그램**: 기술 스택, 구조도
- **와이어프레임/플로우차트**: 사용자 경험 흐름
- **데이터 모델**: 필요한 경우

## 4. 실행 계획
- **마일스톤 & 타임라인**: 주요 체크포인트들
- **태스크 분해**: 구체적인 작업 항목들
- **리소스 계획**: 필요한 도구, 기술, 시간

---

# CS AI 에이전트 프로젝트

## 프로젝트 개요
투비네트웍스 글로벌의 FAQ 자동 응답 시스템 구축

## 전체 시스템 아키텍처

### 전체 워크플로우
```
[스케줄러 - 매 30분마다]
    ↓
[미응답 FAQ 수집 API]
    ↓
[AI 에이전트 코어] ← 여기가 초기 구상 범위
    ↓
[CS 검수 UI]
    ↓
[판매채널 등록 API]
```

### AI 에이전트 코어 아키텍처 (핵심)

```
[질문 입력]
    ↓
[1. 질문 분석 & 분류]
   - 질문 유형 파악 (제품/배송/환불/기술)
   - 복잡도 평가
    ↓
[2. 컨텍스트 수집]
   - 고객 정보 API 호출
   - 주문 이력 조회
   - 구매 제품 확인
    ↓
[3. RAG 검색]
   - Vector DB (유사 FAQ 검색)
   - Knowledge Base (제품 스펙)
   - 과거 Q&A 이력
    ↓
[4. 신뢰도 평가]
   - 충분한 정보 확보?
   - 전문 지식 필요 여부?
   - 답변 가능 여부 판단
    ↓
    ├─ [신뢰도 낮음] → "CS 검토 필요" 플래그
    └─ [신뢰도 높음] ↓
                    [5. Claude 답변 생성]
                       - MCP 도구 활용
                       - 구조화된 프롬프트
                       - 출처 정보 포함
                    ↓
                    [답변 + 메타데이터 반환]
```

---

# 기술 스택 선정 과정 및 근거

## Vector DB와 NoSQL의 관계 이해

### 핵심 개념
**Vector DB와 NoSQL은 서로 대체재가 아닌 보완재입니다. 프로젝트에 둘 다 필요합니다.**

### Vector DB (Weaviate)의 역할
**목적**: 의미적 유사도 검색 (Semantic Search)

고객이 "이 키보드 맥북에서 쓸 수 있나요?"라고 질문하면, Vector DB는 이를 임베딩 벡터로 변환하여 의미적으로 유사한 과거 FAQ를 찾습니다. 단어가 정확히 일치하지 않아도 '의미'가 비슷한 질문들을 검색할 수 있습니다.

**저장되는 데이터**:
- FAQ 질문들의 임베딩 벡터
- 제품 설명의 임베딩 벡터
- 과거 Q&A의 임베딩 벡터
- 검색 결과: 유사도 점수와 문서 ID

### NoSQL (MongoDB)의 역할
**목적**: 실제 데이터 저장 및 구조화된 쿼리

Vector DB에서 유사한 FAQ ID를 찾았다면, MongoDB에서 해당 FAQ의 실제 텍스트, 제품의 전체 스펙, 고객 정보 등을 가져옵니다.

**저장되는 데이터**:
- 제품 전체 스펙 (JSON 형태)
- 고객 정보
- 주문 이력
- FAQ 원본 텍스트
- 카테고리, 태그 등 메타데이터

### 실제 작동 흐름
```
[고객 질문: "이 키보드 맥북에서 쓸 수 있나요?"]
    ↓
1. Weaviate에서 의미적으로 유사한 FAQ 찾기
   → 결과: FAQ ID = [123, 456, 789], 유사도 점수 = [0.92, 0.87, 0.81]
    ↓
2. MongoDB에서 해당 FAQ의 실제 내용 가져오기
   db.faqs.find({"id": {"$in": [123, 456, 789]}})
   → 결과: "macOS 호환 가능, Bluetooth 5.1 지원..."
    ↓
3. 고객이 구매한 제품 확인
   db.customers.find_one({"id": customer_id})
    ↓
4. 해당 제품의 상세 스펙 가져오기
   db.products.find_one({"id": "KB-001"})
    ↓
5. 모든 정보를 Claude에게 전달해서 답변 생성
```

**비유로 이해하기**:
- **Vector DB (Weaviate)**: 도서관의 사서 (질문하면 관련 책 찾아줌)
- **NoSQL (MongoDB)**: 도서관의 책장 (실제 책 내용이 저장된 곳)

---

## Vector DB 후보 상세 비교

### 1. Weaviate

**핵심 특징**:
- 오픈소스 벡터 데이터베이스 (BSD-3 라이선스)
- GraphQL 쿼리 언어 사용
- 하이브리드 검색 (벡터 + 키워드) 내장
- 멀티모달 지원 (텍스트, 이미지 동시 임베딩)
- RESTful API 제공
- Kubernetes 네이티브

**장점**:
- **하이브리드 검색 강력**: 의미 검색과 키워드 검색을 동시에 수행 가능
- **문서화 우수**: 공식 문서가 매우 상세하고 예제 풍부
- **커뮤니티 활발**: GitHub 스타 10k+, 활발한 Discord 커뮤니티
- **멀티모달 지원**: 향후 제품 이미지 기반 문의 대응 가능
- **필터링 기능**: 복잡한 조건 필터링 지원
- **Python/JavaScript SDK 성숙**: 개발 생산성 우수
- **클라우드 & 셀프호스팅 모두 지원**

**단점**:
- 초기 설정이 Qdrant보다 복잡
- GraphQL 학습 필요 (하지만 RESTful도 지원)
- 메모리 사용량이 다소 높음
- 대규모 데이터 시 최적화 필요

**코드 예시**:
```python
import weaviate

client = weaviate.Client("http://localhost:8080")

# 하이브리드 검색 (벡터 + 키워드)
result = client.query.get("FAQ", ["question", "answer"]) \
    .with_hybrid(
        query="블루투스 연결 안됨",
        alpha=0.7  # 0=순수 키워드, 1=순수 벡터, 0.7=혼합
    ) \
    .with_where({
        "path": ["product_category"],
        "operator": "Equal",
        "valueString": "keyboard"
    }) \
    .with_limit(5) \
    .do()
```

### 2. Milvus

**핵심 특징**:
- LF AI & Data Foundation 프로젝트 (Apache 2.0)
- 대규모 벡터 검색 최적화
- GPU 가속 지원
- 분산 아키텍처 (클러스터링)
- 다양한 인덱스 타입 (IVF, HNSW, ANNOY 등)

**장점**:
- **대규모 성능 최고**: 10억+ 벡터 처리 가능
- **GPU 가속**: CUDA 지원으로 검색 속도 극대화
- **프로덕션 안정성**: 엔터프라이즈급 안정성
- **모니터링 도구**: Attu GUI 제공
- **백업/복구 완벽**: 데이터 관리 기능 우수

**단점**:
- **설정 복잡도 매우 높음**: Docker Compose 설정만 20줄+
- **리소스 요구사항 높음**: 최소 4GB RAM 필요
- **러닝 커브 높음**: 초기 학습 시간 소요
- **소규모 프로젝트 오버스펙**

**추천 상황**: 수십만 개 이상의 벡터, 미래 확장성 최우선

### 3. Qdrant

**핵심 특징**:
- Rust 기반 (성능 최적화)
- RESTful API + gRPC
- 단일 바이너리 실행
- 강력한 필터링
- Payload 저장 가능

**장점**:
- **설치 가장 간단**: Docker 한 줄로 실행
- **Python SDK 직관적**: 학습 곡선 최저
- **메모리 효율 우수**
- **빠른 프로토타입**: 설정 시간 최소화

**단점**:
- 대규모 성능은 Milvus보다 낮음
- 하이브리드 검색 미지원
- GUI 도구 부족

**추천 상황**: 빠른 시작, 중소규모 프로젝트

### 4. OpenSearch (with k-NN plugin)

**핵심 특징**:
- Elasticsearch 포크
- 풀텍스트 검색 + 벡터 검색
- k-NN 플러그인
- Kibana 포크로 시각화

**장점**:
- **풀텍스트 검색 최강**
- **로그 분석 통합**
- **대시보드 완벽**

**단점**:
- **벡터 검색이 주 기능 아님**: 부가 기능 수준
- **리소스 사용량 매우 높음**: Java 기반
- **라이선스 이슈 존재**

**추천 상황**: 이미 Elasticsearch 사용 중, 로그 분석 필요

### 5. DeepLake

**핵심 특징**:
- AI/ML 데이터셋 관리
- 멀티모달 데이터 레이크
- Git-like 버전 관리

**장점**:
- **데이터 버전 관리**
- **ML 워크플로우 통합**
- **실험 추적 용이**

**단점**:
- **프로덕션용 아님**: 연구/개발용
- **성능 제한적**
- **커뮤니티 작음**

**추천 상황**: 모델 실험 단계, 연구 프로젝트

### 6. MongoDB Vector Search

**핵심 특징**:
- MongoDB Atlas의 벡터 검색 기능
- 기존 MongoDB 문법 사용
- 하나의 DB로 통합

**장점**:
- **인프라 단순화**: 별도 Vector DB 불필요
- **관리 오버헤드 최소**
- **트랜잭션 지원**

**단점**:
- **성능 제한적**: 전문 Vector DB보다 떨어짐
- **Atlas 전용**: 셀프호스팅 불가
- **유료**: 무료 티어 제한

**추천 상황**: 소규모, 인프라 단순화 최우선

---

## Vector DB 비교표

| 특징 | Weaviate | Milvus | Qdrant | OpenSearch | DeepLake | MongoDB |
|------|----------|--------|--------|------------|----------|---------|
| **설치 난이도** | 중간 | 어려움 | 쉬움 | 어려움 | 쉬움 | 쉬움 |
| **성능 (대규모)** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| **성능 (소규모)** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **메모리 효율** | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **하이브리드 검색** | ✅ 내장 | ❌ | ❌ | ✅ 강력 | ❌ | ✅ 기본 |
| **멀티모달** | ✅ | ✅ | ❌ | ❌ | ✅ | ❌ |
| **필터링** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| **셀프호스팅** | ✅ | ✅ | ✅ | ✅ | ✅ | ⚠️ 제한적 |
| **클라우드 버전** | ✅ | ✅ | ✅ | ✅ AWS | ✅ | ✅ Atlas |
| **라이선스** | BSD-3 | Apache 2.0 | Apache 2.0 | Apache 2.0 | GPL-3.0 | SSPL |
| **문서 품질** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **커뮤니티** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **학습 곡선** | 중간 | 높음 | 낮음 | 높음 | 중간 | 낮음 |
| **추천 규모** | 1K~10M | 100K~1B+ | 1K~1M | 10K~100M | 1K~100K | 1K~100K |
| **주요 용도** | 프로덕션 | 대규모 | 프로토타입 | 로그+검색 | 연구 | 통합 |

---

## 최종 선택: Weaviate + MongoDB

### 선택 근거

#### 1. 하이브리드 검색의 필요성
CS 문의는 의미 검색만으로 해결되지 않는 경우가 많습니다.

**시나리오 예시**:
```
고객 질문: "KB-TKL-001 펌웨어 v2.3 버그 있나요?"

의미 검색만 사용 시:
→ "키보드 문제", "펌웨어 업데이트" 등 일반적인 결과

하이브리드 검색 사용 시:
→ 정확한 모델명 "KB-TKL-001"과 버전 "v2.3"을 키워드로 필터링
→ 의미적으로도 유사한 "버그" 관련 FAQ 검색
→ 훨씬 정확한 결과
```

Weaviate는 `alpha` 파라미터로 벡터 검색과 키워드 검색의 비율을 조정할 수 있어, 상황에 맞는 최적의 검색이 가능합니다.

#### 2. 멀티모달 지원 (미래 확장성)
현재는 텍스트 기반 FAQ이지만, 향후 다음과 같은 확장 가능:

- **제품 이미지 기반 문의**: "이 제품 색상이 뭔가요?" (이미지 첨부)
- **비교 문의**: "이 두 제품 차이가 뭔가요?" (2개 이미지 첨부)
- **시각적 문제 설명**: "이 부분이 깨졌어요" (사진 첨부)

Weaviate는 텍스트와 이미지를 동일한 벡터 공간에서 검색 가능하므로, 추가 인프라 없이 멀티모달 검색으로 확장할 수 있습니다.

#### 3. 필터링 기능
제품 카테고리, 날짜 범위, 고객 등급 등 복잡한 필터링이 필요:

```python
# Weaviate 필터링 예시
result = client.query.get("FAQ", ["question", "answer"]) \
    .with_hybrid(query="블루투스 연결") \
    .with_where({
        "operator": "And",
        "operands": [
            {
                "path": ["product_category"],
                "operator": "Equal",
                "valueString": "keyboard"
            },
            {
                "path": ["updated_at"],
                "operator": "GreaterThan",
                "valueDate": "2024-01-01T00:00:00Z"
            }
        ]
    }) \
    .do()
```

#### 4. 커뮤니티 및 생태계
- **GitHub Stars**: 10,000+ (활발한 개발)
- **Discord 커뮤니티**: 실시간 질문 답변
- **프로덕션 레퍼런스**: Spotify, Red Hat 등 대기업 사용
- **문서 품질**: 튜토리얼, 예제, 가이드 매우 풍부
- **LangChain/LlamaIndex 통합**: 기존 AI 생태계와 완벽 호환

#### 5. 개발 생산성
```python
# Weaviate - 직관적인 Python SDK
import weaviate

client = weaviate.Client("http://localhost:8080")

# 데이터 추가
client.data_object.create(
    data_object={
        "question": "키보드 블루투스 연결 방법",
        "answer": "...",
        "product_id": "KB-001"
    },
    class_name="FAQ"
)

# 검색
result = client.query.get("FAQ", ["question", "answer"]) \
    .with_hybrid(query="블루투스 페어링") \
    .with_limit(5) \
    .do()
```

코드가 읽기 쉽고, 체이닝 방식으로 복잡한 쿼리도 간결하게 표현 가능합니다.

#### 6. MongoDB와의 시너지
**Weaviate**: ID와 유사도 점수 반환
**MongoDB**: 실제 데이터 저장 및 복잡한 쿼리

```python
# 1. Weaviate에서 유사 FAQ 검색
weaviate_results = client.query.get("FAQ", ["faq_id", "score"]) \
    .with_hybrid(query=user_question) \
    .with_limit(5) \
    .do()

faq_ids = [r["faq_id"] for r in weaviate_results["data"]["Get"]["FAQ"]]

# 2. MongoDB에서 상세 정보 가져오기
faqs = db.faqs.find({"_id": {"$in": faq_ids}})
product = db.products.find_one({"product_id": customer_product_id})

# 3. 모든 정보를 Claude에게 전달
context = {
    "similar_faqs": faqs,
    "product_spec": product,
    "customer_history": customer_orders
}
```

#### 7. 비용 효율성
- **오픈소스**: 완전 무료 (BSD-3 라이선스)
- **셀프호스팅**: AWS EC2 등에서 자체 운영 가능
- **클라우드 옵션**: 필요 시 Weaviate Cloud 전환 용이
- **리소스 효율**: 중간 규모 서버로 충분 (Milvus 대비)

#### 8. Qdrant 대비 장점
Qdrant도 우수한 선택지지만, 다음 이유로 Weaviate 선택:

| 기능 | Weaviate | Qdrant |
|------|----------|--------|
| 하이브리드 검색 | ✅ 내장 | ❌ 별도 구현 필요 |
| 멀티모달 | ✅ 지원 | ❌ 텍스트만 |
| 커뮤니티 크기 | 더 큼 | 성장 중 |
| 문서 품질 | 매우 우수 | 우수 |
| 설정 복잡도 | 중간 | 매우 쉬움 |

Qdrant의 장점인 "설정 간편함"보다, Weaviate의 "기능 완성도"가 장기적으로 더 중요하다고 판단했습니다.

---

## MongoDB 선택 근거

### 1. 가변 스키마 완벽 지원
우리 프로젝트의 핵심 요구사항인 "제품별로 컬럼이 다름" 문제를 완벽히 해결:

```json
// 블루투스 지원 키보드
{
  "product_id": "KB-001",
  "name": "무선 키보드",
  "category": "keyboard",
  "connectivity": {
    "bluetooth": {
      "version": "5.1",
      "compatible_devices": ["iOS", "Android", "Windows"],
      "pairing_method": "자동",
      "range_meters": 10
    },
    "usb": {
      "type": "USB-C",
      "cable_length": 1.5
    }
  },
  "battery": {
    "type": "리튬이온",
    "capacity_mah": 2000
  }
}

// 유선 전용 키보드
{
  "product_id": "KB-002",
  "name": "유선 키보드",
  "category": "keyboard",
  "connectivity": {
    "usb": {
      "type": "USB-A",
      "cable_length": 2.0
    }
  }
  // bluetooth, battery 필드 자체가 없음 → 문제 없음!
}

// 마우스 (완전히 다른 스키마)
{
  "product_id": "MS-001",
  "name": "게이밍 마우스",
  "category": "mouse",
  "sensor": {
    "type": "광학",
    "dpi": [400, 800, 1600, 3200],
    "polling_rate_hz": 1000
  },
  "buttons": 8,
  "rgb_lighting": true
}
```

MongoDB는 각 문서가 독립적인 스키마를 가질 수 있어, 제품 타입마다 다른 필드 구조를 자유롭게 사용할 수 있습니다.

### 2. 쿼리 유연성
```python
# 블루투스 지원 제품만 검색
bluetooth_products = db.products.find({
    "connectivity.bluetooth": {"$exists": True}
})

# 특정 DPI를 지원하는 마우스 검색
high_dpi_mice = db.products.find({
    "category": "mouse",
    "sensor.dpi": {"$gte": 3000}
})

# 복합 조건
recent_keyboards = db.products.find({
    "category": "keyboard",
    "updated_at": {"$gte": datetime(2024, 1, 1)},
    "$or": [
        {"connectivity.bluetooth.version": "5.1"},
        {"connectivity.usb.type": "USB-C"}
    ]
})
```

### 3. 트랜잭션 지원
CS 사원이 답변을 승인할 때, 여러 컬렉션을 동시에 업데이트해야 하는 경우:

```python
with client.start_session() as session:
    with session.start_transaction():
        # 1. FAQ 상태 업데이트
        db.faqs.update_one(
            {"_id": faq_id},
            {"$set": {"status": "answered"}},
            session=session
        )
        
        # 2. 답변 저장
        db.answers.insert_one({
            "faq_id": faq_id,
            "answer": answer_text,
            "created_by": "AI",
            "approved_by": cs_employee_id
        }, session=session)
        
        # 3. 로그 기록
        db.logs.insert_one({
            "action": "answer_approved",
            "timestamp": datetime.now()
        }, session=session)
        
        # 모두 성공하거나, 모두 실패 (원자성 보장)
```

### 4. 집계 파이프라인
비즈니스 인사이트 추출:

```python
# 가장 많이 문의되는 제품 카테고리
pipeline = [
    {"$group": {
        "_id": "$product_category",
        "count": {"$sum": 1}
    }},
    {"$sort": {"count": -1}},
    {"$limit": 10}
]
top_categories = db.faqs.aggregate(pipeline)

# 답변 품질 분석
pipeline = [
    {"$match": {"answered_by": "AI"}},
    {"$group": {
        "_id": "$cs_action",
        "avg_confidence": {"$avg": "$confidence_score"},
        "count": {"$sum": 1}
    }}
]
quality_metrics = db.faqs.aggregate(pipeline)
```

### 5. 인덱싱 전략
자주 검색되는 필드에 인덱스 생성:

```python
# 복합 인덱스
db.products.create_index([
    ("category", 1),
    ("updated_at", -1)
])

# 텍스트 인덱스 (MongoDB 풀텍스트 검색)
db.faqs.create_index([
    ("question", "text"),
    ("answer", "text")
])

# 부분 인덱스 (특정 조건만)
db.products.create_index(
    [("connectivity.bluetooth.version", 1)],
    partialFilterExpression={"connectivity.bluetooth": {"$exists": True}}
)
```

### 6. Change Streams (실시간 모니터링)
데이터 변경사항 실시간 추적:

```python
# 새로운 FAQ가 등록되면 자동으로 처리
with db.faqs.watch() as stream:
    for change in stream:
        if change['operationType'] == 'insert':
            new_faq = change['fullDocument']
            # AI 에이전트 트리거
            process_new_faq(new_faq)
```

### 7. 개발 생산성
```python
# PyMongo - 매우 직관적
from pymongo import MongoClient

client = MongoClient("mongodb://localhost:27017/")
db = client.cs_database

# 데이터 추가
product = {
    "product_id": "KB-001",
    "name": "무선 키보드",
    "specs": {...}
}
db.products.insert_one(product)

# 데이터 조회
product = db.products.find_one({"product_id": "KB-001"})

# 데이터 수정
db.products.update_one(
    {"product_id": "KB-001"},
    {"$set": {"specs.firmware_version": "v2.4.0"}}
)
```

### 8. 도구 생태계
- **MongoDB Compass**: GUI 관리 도구
- **Studio 3T**: 고급 쿼리 빌더
- **MongoDB Atlas**: 클라우드 매니지드 서비스
- **Backup/Restore**: 완벽한 백업 솔루션
- **Monitoring**: 실시간 성능 모니터링

---

## 기술 스택 최종 구성

### 전체 아키텍처
```
┌─────────────────┐
│   사용자 질문    │
└────────┬────────┘
         ↓
┌─────────────────┐
│  질문 분석       │
│  (FastAPI)      │
└────────┬────────┘
         ↓
    ┌────┴────┐
    ↓         ↓
┌─────┐   ┌─────────┐
│Weaviate│ │ MongoDB │
│유사FAQ │ │제품스펙  │
│검색    │ │고객정보  │
└────┬──┘ └────┬────┘
     │         │
     └────┬────┘
          ↓
    ┌─────────┐
    │ Claude  │
    │ (MCP)   │
    └────┬────┘
         ↓
    ┌─────────┐
    │답변+신뢰도│
    └────┬────┘
         ↓
    ┌─────────┐
    │CS 검수 UI│
    └─────────┘
```

### MCP 서버 구성
```
├─ weaviate-server (유사 FAQ 검색)
├─ mongodb-server (제품 스펙, 고객 정보)
├─ customer-api-server (주문 이력 API)
└─ approval-queue-server (검수 대기열)
```

### 신뢰도 평가 시스템
```python
def calculate_confidence(question, weaviate_results, mongodb_data):
    score = 0
    
    # Weaviate 검색 결과 품질
    if max(r["_additional"]["score"] for r in weaviate_results) > 0.85:
        score += 30
    
    # 제품 스펙 최신성 (MongoDB)
    if mongodb_data["product"]["updated_at"] > datetime.now() - timedelta(days=30):
        score += 20
    
    # 전문 키워드 감지
    technical_keywords = ['펌웨어', '드라이버', '호환성', 'QC']
    if any(kw in question for kw in technical_keywords):
        score -= 25
    
    # 과거 유사 질문 성공률 (MongoDB 통계)
    similar_success = mongodb_data["statistics"]["success_rate"]
    if similar_success > 0.9:
        score += 20
    
    # 고객-제품 매칭 (MongoDB)
    if mongodb_data["customer"]["purchased_products"]:
        score += 10
    
    return score
```

### Claude 프롬프트 설계
```
당신은 투비네트웍스 글로벌 CS AI입니다.

[제공된 정보]
- Weaviate에서 검색한 유사 FAQ: {similar_faqs}
- MongoDB에서 가져온 제품 스펙: {product_specs}
- 고객 구매 이력: {customer_history}

[역할]
- 위 정보를 기반으로 정확하고 친절하게 답변
- 불확실하면 "전문 상담 필요" 명시
- 추측 금지

[필수 포함]
1. 고객명 호칭 (예: "김철수님")
2. 구매 제품 확인 멘트
3. 구체적 해결 방법
4. 추가 도움 연락처

[출력 형식]
{
  "answer": "고객에게 보낼 답변",
  "confidence": 0-100,
  "sources": [
    {"type": "faq", "id": "FAQ-123", "relevance": 0.92},
    {"type": "product_spec", "field": "bluetooth.version"}
  ],
  "requires_human_review": true/false,
  "reasoning": "판단 근거",
  "tags": ["카테고리", "우선순위"]
}
```

---

## CS 검수 UI 구성

### 기술 스택
- **Frontend**: Next.js 15 + TypeScript + shadcn/ui
- **Backend**: FastAPI (Python)
- **실시간**: Server-Sent Events
- **상태 관리**: Zustand
- **API 통신**: TanStack Query

### UI 예시
```
┌──────────────────────────────────────────────┐
│ 📋 답변 검수 대기열 (15건)         🔄 새로고침 │
├──────────────────────────────────────────────┤
│                                              │
│ ┌──────────────────────────────────────────┐ │
│ │ [우선순위 높음] 🔴  신뢰도: 65% ⚠️       │ │
│ │                                          │ │
│ │ 질문 ID: FAQ-2025-09-30-042              │ │
│ │ 고객: 김철수 (CUST-12345)                │ │
│ │ 구매 제품: KB-TKL-001 (무선 키보드)       │ │
│ │ 문의 시간: 2시간 전                       │ │
│ │                                          │ │
│ │ [질문]                                   │ │
│ │ "이 키보드가 맥북 프로 2024에서           │ │
│ │  블루투스로 연결되나요?"                 │ │
│ │                                          │ │
│ │ [AI 생성 답변]                           │ │
│ │ 안녕하세요, 김철수님.                    │ │
│ │                                          │ │
│ │ KB-TKL-001 무선 키보드 구매 감사합니다.   │ │
│ │ 해당 제품은 Bluetooth 5.1을 지원하며,    │ │
│ │ macOS 12 이상에서 완벽하게 호환됩니다.   │ │
│ │                                          │ │
│ │ 맥북 프로 2024는 macOS 14를 사용하므로   │ │
│ │ 문제없이 연결 가능합니다...              │ │
│ │                                          │ │
│ │ [사용된 출처]                            │ │
│ │ • FAQ #247 "맥북 블루투스 페어링"        │ │
│ │   (유사도 92%, 해결율 94%)               │ │
│ │ • 제품 스펙 문서 (최근 업데이트:         │ │
│ │   2025-09-15)                           │ │
│ │ • 고객 구매 확인: 2025-09-20            │ │
│ │                                          │ │
│ │ [판단 근거]                              │ │
│ │ - 유사 FAQ 발견 (92% 일치)              │ │
│ │ - 제품 스펙 최신 정보 확인               │ │
│ │ ⚠️ 신뢰도 중간: 전문 용어 포함           │ │
│ │                                          │ │
│ │ [✅ 승인]  [✏️ 수정]  [❌ 거부]           │ │
│ └──────────────────────────────────────────┘ │
│                                              │
│ ┌──────────────────────────────────────────┐ │
│ │ [일반] 🟢  신뢰도: 88% ✅                │ │
│ │ ...                                      │ │
└──────────────────────────────────────────────┘
```

---

## 로깅 & 데이터 수집

### MongoDB 로그 스키마
```json
{
  "timestamp": "2025-09-30T14:32:00Z",
  "question_id": "FAQ-2025-09-30-042",
  "customer_id": "CUST-12345",
  "customer_name": "김철수",
  "product_id": "KB-TKL-001",
  
  "question": {
    "text": "이 키보드가 맥북 프로 2024에서 블루투스로 연결되나요?",
    "category": "technical",
    "complexity": "medium"
  },
  
  "weaviate_search": {
    "query_vector": [...],
    "results": [
      {
        "faq_id": "FAQ-247",
        "similarity_score": 0.92,
        "text": "맥북 블루투스 페어링 방법..."
      }
    ],
    "search_time_ms": 45
  },
  
  "mongodb_lookup": {
    "product_spec": {
      "bluetooth_version": "5.1",
      "compatible_os": ["Windows 10+", "macOS 12+"]
    },
    "customer_history": {
      "purchase_date": "2025-09-20",
      "previous_inquiries": 2
    },
    "lookup_time_ms": 12
  },
  
  "ai_generation": {
    "model": "claude-sonnet-4-20250514",
    "confidence_score": 65,
    "generated_answer": "안녕하세요, 김철수님...",
    "sources": [
      {"type": "faq", "id": "FAQ-247", "relevance": 0.92},
      {"type": "product_spec", "field": "connectivity.bluetooth"}
    ],
    "requires_human_review": true,
    "reasoning": "유사 FAQ 발견, 전문 용어 포함으로 검토 권장",
    "generation_time_ms": 3200
  },
  
  "cs_review": {
    "action": "approved",
    "reviewer_id": "EMP-567",
    "reviewer_name": "이영희",
    "modifications": null,
    "review_time_ms": 15000,
    "review_timestamp": "2025-09-30T14:35:00Z"
  },
  
  "final_answer": "안녕하세요, 김철수님...",
  
  "customer_feedback": {
    "satisfaction_score": 5,
    "feedback_text": "빠른 답변 감사합니다",
    "feedback_timestamp": "2025-09-30T15:20:00Z"
  },
  
  "total_processing_time_ms": 18257,
  "status": "completed"
}
```

### 활용 방안
1. **모델 성능 추적**: confidence_score vs cs_action 분석
2. **파인튜닝 데이터셋**: approved 답변들을 학습 데이터로 활용
3. **비즈니스 인사이트**: 가장 많은 문의 제품, 시간대별 패턴
4. **시스템 최적화**: 각 단계별 처리 시간 분석

---

## 개발 단계 (상세)

### Phase 1: 인프라 구축 (1주)
```
[할 일]
✅ Weaviate Docker 설치 및 설정
✅ MongoDB Docker 설치 및 설정
✅ Python 가상환경 구성
✅ 필수 라이브러리 설치
   - weaviate-client
   - pymongo
   - fastapi
   - anthropic

[산출물]
- docker-compose.yml
- requirements.txt
- .env (환경 변수)
```

### Phase 2: 데이터 준비 (1주)
```
[할 일]
✅ 10개 제품 스펙 JSON 작성
✅ 50개 샘플 FAQ 작성
✅ MongoDB에 데이터 임포트
✅ FAQ 임베딩 생성 (OpenAI/Cohere)
✅ Weaviate에 벡터 저장

[산출물]
- /data/products/*.json
- /data/faqs/*.json
- /scripts/import_to_mongodb.py
- /scripts/embed_and_upload.py
```

### Phase 3: AI 에이전트 코어 (2주)
```
[할 일]
✅ FastAPI 서버 구축
✅ Weaviate 검색 로직
✅ MongoDB 조회 로직
✅ 신뢰도 평가 알고리즘
✅ Claude MCP 통합
✅ 답변 생성 파이프라인

[산출물]
- /backend/main.py
- /backend/services/weaviate_service.py
- /backend/services/mongodb_service.py
- /backend/services/claude_service.py
- /backend/models/confidence.py
```

### Phase 4: CS 검수 UI (2주)
```
[할 일]
✅ Next.js 프로젝트 초기화
✅ 대기열 목록 UI
✅ 답변 검수 상세 페이지
✅ 승인/수정/거부 기능
✅ 실시간 업데이트 (SSE)
✅ 통계 대시보드

[산출물]
- /frontend/app/page.tsx
- /frontend/components/ReviewQueue.tsx
- /frontend/components/ReviewDetail.tsx
- /frontend/hooks/useSSE.ts
```

### Phase 5: 통합 테스트 (1주)
```
[할 일]
✅ 엔드투엔드 테스트
✅ 성능 테스트
✅ 에러 핸들링 검증
✅ 로깅 시스템 검증
✅ 문서화

[산출물]
- /tests/e2e/*.test.py
- /tests/performance/*.test.py
- /docs/API.md
- /docs/DEPLOYMENT.md
```

### Phase 6: 프로덕션 준비 (1주)
```
[할 일]
✅ 모니터링 대시보드
✅ 알림 시스템 (Slack/Email)
✅ 백업 전략
✅ CI/CD 파이프라인
✅ 보안 감사

[산출물]
- /monitoring/grafana-dashboard.json
- /scripts/backup.sh
- .github/workflows/deploy.yml
- /docs/SECURITY.md
```

---

## 기대 효과

### 정량적 효과
- **응답 시간 단축**: 평균 2시간 → 30분 (75% 감소)
- **CS 인력 효율**: 답변 작성 시간 80% 절감
- **처리량 증가**: 일일 100건 → 500건 가능
- **일관성 향상**: 답변 품질 편차 최소화

### 정성적 효과
- 고객 만족도 향상 (빠른 응답)
- CS 사원 업무 만족도 향상 (반복 작업 감소)
- 제품 개선 인사이트 도출 (문의 데이터 분석)
- 향후 완전 자동화 가능성 확보

---

## 위험 관리

### 기술적 위험
- **Weaviate 성능 이슈**: 벡터 수 증가 시 → 인덱스 최적화, 샤딩
- **MongoDB 용량 부족**: 로그 누적 시 → TTL 인덱스, 아카이빙
- **Claude API 비용**: 요청 증가 시 → 캐싱, 배치 처리

### 운영 위험
- **잘못된 답변**: 신뢰도 임계값 조정, 사람 검수 강화
- **시스템 다운**: 중복 인프라, Health Check 강화
- **데이터 유출**: 암호화, 접근 제어, 감사 로그

---

## 시작 가이드

이 문서는 프로젝트의 전체 구상과 기술 스택 선정 근거를 담고 있습니다. 다음 단계로 진행하려면:

1. **환경 설정**: Docker 설치, Python 가상환경 구성
2. **데이터 준비**: 제품 스펙 JSON 작성
3. **프로토타입**: Phase 1~3 순차 진행

자세한 구현 가이드는 별도 문서로 작성 예정입니다.
